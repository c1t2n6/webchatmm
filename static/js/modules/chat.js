// Chat and Matching Module
class ChatModule {
    constructor(app) {
        this.app = app;
        this.websocket = null;
        this.chatWebSocket = null;
        this.reconnectAttempts = 0;
        this.maxReconnectAttempts = 5;
        this.reconnectDelay = 1000;
        this.typingTimer = null;
        
        // Ki·ªÉm tra xem c√≥ pending chat connection kh√¥ng
        this.checkPendingChatConnection();
    }
    
    async init() {
        console.log('üîç Chat - ChatModule init called');
        
        // ƒê·ª£i m·ªôt ch√∫t ƒë·ªÉ ƒë·∫£m b·∫£o DOM ƒë√£ s·∫µn s√†ng
        await new Promise(resolve => setTimeout(resolve, 100));
        
        // Ki·ªÉm tra v√† kh√¥i ph·ª•c tr·∫°ng th√°i chat n·∫øu c·∫ßn
        if (this.app.currentUser) {
            await this.restoreChatState();
        }
        
        // Th√™m event listener ƒë·ªÉ ki·ªÉm tra tr·∫°ng th√°i khi page load
        window.addEventListener('load', () => {
            console.log('üîç Chat - Page loaded, checking chat state...');
            if (this.app.currentUser) {
                this.restoreChatState();
            }
        });
        
        // Ki·ªÉm tra tr·∫°ng th√°i ngay l·∫≠p t·ª©c n·∫øu DOM ƒë√£ s·∫µn s√†ng
        if (document.readyState === 'complete') {
            console.log('üîç Chat - DOM already complete, checking chat state immediately...');
            if (this.app.currentUser) {
                this.restoreChatState();
            }
        }
        
        // Th√™m logic ƒë·ªÉ t·ª± ƒë·ªông kh√¥i ph·ª•c chat state sau khi user ƒë∆∞·ª£c load
        // ƒê·ª£i m·ªôt ch√∫t ƒë·ªÉ ƒë·∫£m b·∫£o user data ƒë√£ ƒë∆∞·ª£c load
        setTimeout(async () => {
            if (this.app.currentUser) {
                console.log('üîç Chat - Auto-restoring chat state after delay...');
                await this.restoreChatState();
            }
        }, 1000);
    }
    
    checkPendingChatConnection() {
        if (this.app.pendingChatConnection) {
            console.log('üîç Chat - Found pending chat connection:', this.app.pendingChatConnection);
            const { roomId, timestamp } = this.app.pendingChatConnection;
            
            // Ki·ªÉm tra xem pending connection c√≥ c√≤n h·ª£p l·ªá kh√¥ng (trong v√≤ng 30 gi√¢y)
            const now = Date.now();
            if (now - timestamp < 30000) { // 30 gi√¢y
                console.log('üîç Chat - Pending connection still valid, connecting to room:', roomId);
                
                // X√≥a pending connection
                delete this.app.pendingChatConnection;
                
                // K·∫øt n·ªëi v√†o room
                if (this.app.currentUser && this.app.currentUser.status.toLowerCase() === 'connected') {
                    this.app.currentRoom = { id: roomId };
                    this.app.showChatRoom();
                    this.connectChatWebSocket(roomId);
                }
            } else {
                console.log('üîç Chat - Pending connection expired, removing');
                delete this.app.pendingChatConnection;
            }
        } else {
            // Kh√¥ng c√≥ pending connection, ki·ªÉm tra xem c√≥ c·∫ßn kh√¥i ph·ª•c chat state kh√¥ng
            this.restoreChatState();
        }
    }
    
    async restoreChatState() {
        console.log('üîç Chat - restoreChatState called');
        console.log('üîç Chat - Current user:', this.app.currentUser);
        console.log('üîç Chat - User status:', this.app.currentUser?.status);
        console.log('üîç Chat - User current_room_id:', this.app.currentUser?.current_room_id);
        
        // Ki·ªÉm tra xem user c√≥ ƒëang trong chat room kh√¥ng
        if (this.app.currentUser && this.app.currentUser.status.toLowerCase() === 'connected' && this.app.currentUser.current_room_id) {
            console.log('üîç Chat - User is in chat room, restoring state...');
            
            // Ki·ªÉm tra xem c√≥ ƒëang ·ªü chat room UI kh√¥ng
            const chatRoom = document.getElementById('chatRoom');
            const waitingRoom = document.getElementById('waitingRoom');
            const searching = document.getElementById('searching');
            
            // N·∫øu ƒëang ·ªü waiting room ho·∫∑c searching, chuy·ªÉn v·ªÅ chat room
            if ((waitingRoom && !waitingRoom.classList.contains('hidden')) || 
                (searching && !searching.classList.contains('hidden'))) {
                console.log('üîç Chat - User is in waiting/searching, redirecting to chat room...');
                this.app.currentRoom = { id: this.app.currentUser.current_room_id };
                this.app.showChatRoom();
            }
            
            // K·∫øt n·ªëi WebSocket n·∫øu ch∆∞a c√≥
            if (!this.chatWebSocket || this.chatWebSocket.readyState !== WebSocket.OPEN) {
                console.log('üîç Chat - Connecting to chat WebSocket...');
                this.connectChatWebSocket(this.app.currentUser.current_room_id);
            }
            
            return true;
        }
        
        // N·∫øu user kh√¥ng c√≥ current_room_id ho·∫∑c status kh√¥ng ph·∫£i connected, 
        // ki·ªÉm tra xem h·ªç c√≥ ƒëang trong room n√†o kh√¥ng
        if (this.app.currentUser) {
            console.log('üîç Chat - User status is not connected or no current_room_id, checking for active rooms...');
            
            try {
                // G·ªçi API ƒë·ªÉ ki·ªÉm tra xem user c√≥ ƒëang trong room n√†o kh√¥ng
                const response = await fetch('/chat/check-room-status', {
                    headers: { 'Authorization': `Bearer ${localStorage.getItem('access_token')}` }
                });
                
                console.log('üîç Chat - Check room status API response status:', response.status);
                
                if (response.ok) {
                    const roomData = await response.json();
                    console.log('üîç Chat - Check room status API response:', roomData);
                    
                    if (roomData.room_id && roomData.status === 'active') {
                        console.log('üîç Chat - Found active room for user:', roomData.room_id);
                        
                        // C·∫≠p nh·∫≠t user status
                        this.app.currentUser.current_room_id = roomData.room_id;
                        this.app.currentUser.status = 'connected';
                        this.app.currentRoom = { id: roomData.room_id };
                        
                        // Chuy·ªÉn v·ªÅ chat room
                        this.app.showChatRoom();
                        
                        // K·∫øt n·ªëi WebSocket
                        this.connectChatWebSocket(roomData.room_id);
                        
                        return true;
                    }
                } else {
                    console.error('üîç Chat - Check room status API failed:', response.status);
                    const errorData = await response.json();
                    console.error('üîç Chat - Error details:', errorData);
                }
            } catch (error) {
                console.error('üîç Chat - Error checking room status:', error);
            }
        }
        
        console.log('üîç Chat - No chat state to restore');
        return false;
    }

    async refreshUserStatus() {
        try {
            const response = await fetch('/user/profile', {
                headers: { 'Authorization': `Bearer ${localStorage.getItem('access_token')}` }
            });
            if (response.ok) {
                this.app.currentUser = await response.json();
                console.log('User status refreshed:', this.app.currentUser.status, this.app.currentUser.current_room_id);
            }
        } catch (error) {
            console.error('Failed to refresh user status:', error);
        }
    }
    
    async startSearch() {
        await this.refreshUserStatus();
        
        // Ki·ªÉm tra pending chat connection tr∆∞·ªõc
        if (this.app.pendingChatConnection) {
            console.log('üîç Chat - Processing pending chat connection in startSearch');
            this.checkPendingChatConnection();
            return;
        }
        
        // Ki·ªÉm tra xem user c√≥ ƒëang trong chat room kh√¥ng
        if (await this.restoreChatState()) {
            console.log('üîç Chat - Chat state restored, no need to search');
            return;
        }
        
        // N·∫øu user ƒë√£ c√≥ room_id v√† status connected, chuy·ªÉn v·ªÅ chat room
        if (this.app.currentUser && this.app.currentUser.status.toLowerCase() === 'connected' && this.app.currentUser.current_room_id) {
            console.log('User already connected to room, redirecting to chat...');
            this.app.currentRoom = { id: this.app.currentUser.current_room_id };
            this.app.showChatRoom();
            this.connectChatWebSocket(this.app.currentUser.current_room_id);
            return;
        }
        
        try {
            const response = await fetch('/chat/search', {
                method: 'POST',
                headers: { 
                    'Content-Type': 'application/json',
                    'Authorization': `Bearer ${localStorage.getItem('access_token')}` 
                },
                body: JSON.stringify({ type: 'chat' })
            });

            if (response.ok) {
                const data = await response.json();
                
                if (data.room_id && data.matched_user) {
                    this.handleMatchFound(data);
                } else {
                    this.app.showSearching();
                    this.connectWebSocket();
                }
            } else {
                const error = await response.json();
                this.app.showError(error.detail || 'Kh√¥ng th·ªÉ b·∫Øt ƒë·∫ßu t√¨m ki·∫øm');
            }
        } catch (error) {
            console.error('Search error:', error);
            this.app.showError('L·ªói k·∫øt n·ªëi');
        }
    }

    async cancelSearch() {
        try {
            await fetch('/chat/cancel-search', {
                method: 'POST',
                headers: { 'Authorization': `Bearer ${localStorage.getItem('access_token')}` }
            });
        } catch (error) {
            console.error('Cancel search error:', error);
        }
        
        this.disconnectWebSocket();
        this.app.showWaitingRoom();
    }

    connectWebSocket() {
        if (this.websocket) {
            console.log('üîç Chat - Closing existing WebSocket connection');
            this.websocket.close();
        }

        const token = localStorage.getItem('access_token');
        console.log('üîç Chat - Connecting to status WebSocket...');
        this.websocket = new WebSocket(`ws://${window.location.host}/ws/status?token=${token}`);

        this.websocket.onopen = () => {
            console.log('üîç Chat - Status WebSocket connected successfully');
            this.reconnectAttempts = 0;
        };

        this.websocket.onmessage = (event) => {
            console.log('üîç Chat - Status WebSocket message received:', event.data);
            const data = JSON.parse(event.data);
            this.handleWebSocketMessage(data);
        };

        this.websocket.onclose = () => {
            console.log('üîç Chat - Status WebSocket disconnected');
            this.handleWebSocketDisconnect();
        };

        this.websocket.onerror = (error) => {
            console.error('üîç Chat - Status WebSocket error:', error);
        };
    }

    handleWebSocketMessage(data) {
        console.log('üîç Chat - WebSocket message received:', data);
        console.log('üîç Chat - Message type:', data.type);
        
        switch (data.type) {
            case 'match_found':
                console.log('üîç Chat - Handling match_found');
                this.handleMatchFound(data);
                break;
            case 'chat_message':
                console.log('üîç Chat - Handling chat_message');
                this.handleChatMessage(data);
                break;
            case 'typing_indicator':
                console.log('üîç Chat - Handling typing_indicator');
                this.handleTypingIndicator(data);
                break;
            case 'like_prompt':
                console.log('üîç Chat - Handling like_prompt');
                this.app.showLikeModal();
                break;
            case 'image_reveal':
                console.log('üîç Chat - Handling image_reveal');
                this.app.handleImageReveal(data);
                break;
            case 'chat_ended':
                console.log('üîç Chat - Handling chat_ended');
                this.app.handleChatEnded();
                break;
            case 'room_ended_by_user':
                console.log('üîç Chat - Handling room_ended_by_user');
                this.handleRoomEndedByUser(data);
                break;
            case 'status_update':
                console.log('üîç Chat - Handling status_update');
                this.handleStatusUpdate(data);
                break;
            default:
                console.log('üîç Chat - Unknown message type:', data.type);
        }
    }

    handleWebSocketDisconnect() {
        if (this.reconnectAttempts < this.maxReconnectAttempts) {
            this.reconnectAttempts++;
            const delay = this.reconnectDelay * Math.pow(2, this.reconnectAttempts - 1);
            
            setTimeout(() => {
                console.log(`Attempting to reconnect... (${this.reconnectAttempts}/${this.maxReconnectAttempts})`);
                this.connectWebSocket();
            }, delay);
        } else {
            this.app.showError('M·∫•t k·∫øt n·ªëi. Vui l√≤ng th·ª≠ l·∫°i.');
            this.app.showWaitingRoom();
        }
    }

    async handleMatchFound(data) {
        if (data.room_id && data.matched_user) {
            this.app.currentRoom = {
                id: data.room_id,
                matched_user: data.matched_user
            };
        } else if (data.room) {
            this.app.currentRoom = data.room;
        }
        
        this.app.showChatRoom();
        this.connectChatWebSocket(this.app.currentRoom.id);
        
        setTimeout(() => {
            this.app.showLikeModal();
        }, 5 * 60 * 1000);
    }

    handleRoomEndedByUser(data) {
        console.log('üîç Chat - Room ended by user notification received:', data);
        console.log('üîç Chat - Current WebSocket state:', this.websocket?.readyState);
        console.log('üîç Chat - Current chat WebSocket state:', this.chatWebSocket?.readyState);
        
        // Show modal th√¥ng b√°o thay v√¨ showError
        this.showRoomEndedModal(data.message || 'Ph√≤ng chat ƒë√£ ƒë∆∞·ª£c k·∫øt th√∫c');
        
        // ‚ùå KH√îNG ƒë√≥ng chat WebSocket ngay l·∫≠p t·ª©c
        // ƒê·ªÉ notification ƒë∆∞·ª£c x·ª≠ l√Ω ho√†n to√†n v√† tr√°nh race condition
    }
    
    handleStatusUpdate(data) {
        console.log('üîç Chat - Status update received:', data);
        
        // C·∫≠p nh·∫≠t user status t·ª´ server
        if (this.app.currentUser && data.user_id === this.app.currentUser.id) {
            console.log('üîç Chat - Updating user status from server');
            console.log('üîç Chat - Old status:', this.app.currentUser.status, 'New status:', data.status);
            console.log('üîç Chat - Old room_id:', this.app.currentUser.current_room_id, 'New room_id:', data.current_room_id);
            
            // C·∫≠p nh·∫≠t tr·∫°ng th√°i
            this.app.currentUser.status = data.status;
            this.app.currentUser.current_room_id = data.current_room_id;
            
            // N·∫øu user ƒë∆∞·ª£c k·∫øt n·ªëi v√†o room, kh√¥i ph·ª•c chat state
            if (data.status === 'connected' && data.current_room_id) {
                console.log('üîç Chat - User connected to room, restoring chat state...');
                this.restoreChatState();
            }
        }
    }
    
    handleRoomClosed(data) {
        console.log('üîç Chat - Room closed notification received:', data);
        console.log('üîç Chat - Current WebSocket state:', this.websocket?.readyState);
        console.log('üîç Chat - Current chat WebSocket state:', this.chatWebSocket?.readyState);
        
        // Show modal th√¥ng b√°o thay v√¨ showError
        this.showRoomEndedModal(data.message || 'Ph√≤ng chat ƒë√£ ƒë√≥ng');
    }
    
    showRoomEndedModal(message) {
        console.log('üîç Chat - Showing room ended modal with message:', message);
        
        // T·∫°o modal HTML
        const modalHTML = `
            <div id="roomEndedModal" class="fixed inset-0 bg-black bg-opacity-50 flex items-center justify-center z-50">
                <div class="bg-white dark:bg-gray-800 rounded-2xl p-8 max-w-md w-full mx-4 text-center">
                    <div class="text-6xl mb-4">üí¨</div>
                    <h3 class="text-2xl font-bold text-gray-900 dark:text-white mb-4">Ph√≤ng Chat ƒê√£ K·∫øt Th√∫c</h3>
                    <p class="text-gray-600 dark:text-gray-300 mb-6">${message}</p>
                    
                    <button id="backToWaitingBtn" class="px-8 py-3 bg-primary text-white rounded-lg hover:bg-primary/90 transition-colors text-lg">
                        V·ªÅ Ph√≤ng Ch·ªù
                    </button>
                </div>
            </div>
        `;
        
        // Th√™m modal v√†o body
        document.body.insertAdjacentHTML('beforeend', modalHTML);
        
        // Th√™m event listener cho n√∫t
        const backToWaitingBtn = document.getElementById('backToWaitingBtn');
        if (backToWaitingBtn) {
            backToWaitingBtn.addEventListener('click', () => {
                console.log('üîç Chat - Back to waiting button clicked');
                
                // ƒê√≥ng WebSocket connections tr∆∞·ªõc khi reload
                if (this.chatWebSocket) {
                    console.log('üîç Chat - Closing chat WebSocket before reload');
                    this.chatWebSocket.close();
                    this.chatWebSocket = null;
                }
                
                if (this.websocket) {
                    console.log('üîç Chat - Closing status WebSocket before reload');
                    this.websocket.close();
                    this.websocket = null;
                }
                
                // Reload page ƒë·ªÉ v·ªÅ ph√≤ng ch·ªù
                console.log('üîç Chat - Reloading page to return to waiting room');
                window.location.reload();
            });
        }
        
        // Auto-close modal sau 10 gi√¢y n·∫øu user kh√¥ng click
        setTimeout(() => {
            const modal = document.getElementById('roomEndedModal');
            if (modal) {
                console.log('üîç Chat - Auto-closing room ended modal after 10 seconds');
                modal.remove();
                
                // T·ª± ƒë·ªông reload page
                console.log('üîç Chat - Auto-reloading page to return to waiting room');
                window.location.reload();
            }
        }, 10000);
    }

    connectChatWebSocket(roomId) {
        console.log('üîç Chat - connectChatWebSocket called with roomId:', roomId);
        const token = localStorage.getItem('access_token');
        console.log('üîç Chat - Connecting to chat WebSocket for room:', roomId);
        const chatWs = new WebSocket(`ws://${window.location.host}/ws/chat/${roomId}?token=${token}`);

        chatWs.onopen = () => {
            console.log('üîç Chat - Chat WebSocket connected successfully to room:', roomId);
            // ‚úÖ Setup typing listeners sau khi WebSocket k·∫øt n·ªëi
            this.setupTypingListeners();
        };

        chatWs.onmessage = (event) => {
            console.log('üîç Chat - Chat WebSocket message received:', event.data);
            const data = JSON.parse(event.data);
            this.handleChatWebSocketMessage(data);
        };

        chatWs.onclose = () => {
            console.log('üîç Chat - Chat WebSocket disconnected from room:', roomId);
        };

        chatWs.onerror = (error) => {
            console.error('üîç Chat - Chat WebSocket error:', error);
        };

        this.chatWebSocket = chatWs;
    }

    handleChatWebSocketMessage(data) {
        console.log('üîç Chat - handleChatWebSocketMessage called with:', data);
        
        switch (data.type) {
            case 'message':
                console.log('üîç Chat - Message received:', data);
                this.addMessageToChat(data);  // ‚úÖ S·ª≠a: truy·ªÅn data thay v√¨ data.message
                break;
            case 'typing':
                console.log('üîç Chat - Typing indicator received:', data);
                this.showTypingIndicator(data.user_id);
                break;
            case 'stop_typing':
                console.log('üîç Chat - Stop typing indicator received:', data);
                this.hideTypingIndicator(data.user_id);
                break;
            case 'room_closed':
                console.log('üîç Chat - Room closed notification received via chat WebSocket:', data);
                this.handleRoomClosed(data);
                break;
            case 'room_ended_by_user':
                console.log('üîç Chat - Room ended by user notification received via chat WebSocket:', data);
                this.handleRoomEndedByUser(data);
                break;
            default:
                console.log('üîç Chat - Unhandled message type:', data.type, data);
        }
    }

    async sendMessage() {
        const input = document.getElementById('messageInput');
        const message = input.value.trim();
        
        if (!message || !this.chatWebSocket) return;

        try {
            // ‚úÖ G·ª≠i stop typing indicator tr∆∞·ªõc khi g·ª≠i tin nh·∫Øn
            this.sendStopTypingIndicator();

            this.chatWebSocket.send(JSON.stringify({
                type: 'message',
                content: message
                // room_id and user_id are handled by backend WebSocket authentication
            }));

            this.addMessageToChat({
                content: message,
                user_id: this.app.currentUser.id,
                timestamp: new Date().toISOString()
            });

            input.value = '';
        } catch (error) {
            console.error('Send message error:', error);
            this.app.showError('Kh√¥ng th·ªÉ g·ª≠i tin nh·∫Øn');
        }
    }

    sendTypingIndicator() {
        if (this.typingTimer) {
            clearTimeout(this.typingTimer);
        }

        if (this.chatWebSocket) {
            // ‚úÖ G·ª≠i typing indicator v·ªõi is_typing = true
            this.chatWebSocket.send(JSON.stringify({
                type: 'typing',
                is_typing: true
                // room_id is handled by backend WebSocket authentication
            }));
        }

        this.typingTimer = setTimeout(() => {
            if (this.chatWebSocket) {
                // ‚úÖ T·ª± ƒë·ªông g·ª≠i stop typing sau 1 gi√¢y
                this.sendStopTypingIndicator();
            }
        }, 1000);
    }

    sendStopTypingIndicator() {
        if (this.typingTimer) {
            clearTimeout(this.typingTimer);
            this.typingTimer = null;
        }

        if (this.chatWebSocket) {
            // ‚úÖ G·ª≠i stop typing indicator v·ªõi is_typing = false
            this.chatWebSocket.send(JSON.stringify({
                type: 'typing',
                is_typing: false
                // room_id is handled by backend WebSocket authentication
            }));
        }
    }

    setupTypingListeners() {
        const input = document.getElementById('messageInput');
        if (!input) return;

        // ‚úÖ G·ª≠i typing indicator khi b·∫Øt ƒë·∫ßu g√µ
        input.addEventListener('input', () => {
            if (this.chatWebSocket) {
                this.sendTypingIndicator();
            }
        });

        // ‚úÖ G·ª≠i stop typing khi input m·∫•t focus
        input.addEventListener('blur', () => {
            if (this.chatWebSocket) {
                this.sendStopTypingIndicator();
            }
        });

        // ‚úÖ G·ª≠i stop typing khi nh·∫•n Enter
        input.addEventListener('keydown', (e) => {
            if (e.key === 'Enter' && this.chatWebSocket) {
                this.sendStopTypingIndicator();
            }
        });
    }

    addMessageToChat(message) {
        const chatMessages = document.getElementById('chatMessages');
        if (!chatMessages) return;
        
        // Ki·ªÉm tra message object c√≥ ƒë√∫ng c·∫•u tr√∫c kh√¥ng
        if (!message || typeof message !== 'object') {
            console.error('üîç Chat - Invalid message object:', message);
            return;
        }
        
        // Ki·ªÉm tra c√°c tr∆∞·ªùng b·∫Øt bu·ªôc
        if (!message.content || !message.user_id || !message.timestamp) {
            console.error('üîç Chat - Message missing required fields:', message);
            return;
        }
        
        // Ki·ªÉm tra currentUser c√≥ t·ªìn t·∫°i kh√¥ng
        if (!this.app.currentUser || !this.app.currentUser.id) {
            console.error('üîç Chat - Current user not available:', this.app.currentUser);
            return;
        }
        
        const messageDiv = document.createElement('div');
        const isOwnMessage = message.user_id === this.app.currentUser.id;
        
        messageDiv.className = `flex ${isOwnMessage ? 'justify-end' : 'justify-start'}`;
        messageDiv.innerHTML = `
            <div class="max-w-xs lg:max-w-md px-4 py-2 rounded-lg chat-bubble ${
                isOwnMessage 
                    ? 'bg-primary text-white' 
                    : 'bg-gray-200 dark:bg-gray-700 text-gray-900 dark:text-white'
            }">
                <p class="text-sm">${this.app.escapeHtml ? this.app.escapeHtml(message.content) : message.content}</p>
                <p class="text-xs opacity-75 mt-1">${this.app.formatTime ? this.app.formatTime(message.timestamp) : message.timestamp}</p>
            </div>
        `;
        
        chatMessages.appendChild(messageDiv);
        chatMessages.scrollTop = chatMessages.scrollHeight;
    }

    showTypingIndicator(userId) {
        if (userId === this.app.currentUser.id) return;
        
        const typingElement = document.querySelector('.typing-indicator');
        if (!typingElement) {
            const chatMessages = document.getElementById('chatMessages');
            if (!chatMessages) return;
            
            const typingDiv = document.createElement('div');
            typingDiv.className = 'flex justify-start typing-indicator';
            typingDiv.innerHTML = `
                <div class="px-4 py-2 bg-gray-200 dark:bg-gray-700 rounded-lg">
                    <p class="text-sm text-gray-600 dark:text-gray-400">ƒêang nh·∫≠p...</p>
                </div>
            `;
            chatMessages.appendChild(typingDiv);
            chatMessages.scrollTop = chatMessages.scrollHeight;
        }
    }

    hideTypingIndicator(userId) {
        if (userId === this.app.currentUser.id) return;
        
        const typingElement = document.querySelector('.typing-indicator');
        if (typingElement) {
            typingElement.remove();
        }
    }

    async endChat() {
        if (!this.app.currentRoom) return;

        try {
            await fetch(`/chat/end/${this.app.currentRoom.id}`, {
                method: 'POST',
                headers: { 'Authorization': `Bearer ${localStorage.getItem('access_token')}` }
            });
        } catch (error) {
            console.error('End chat error:', error);
        }

        this.disconnectWebSocket();
        this.app.currentRoom = null;
        this.app.showEndChatModal();
    }

    async keepActive() {
        if (!this.app.currentRoom) return;

        try {
            await fetch(`/chat/keep/${this.app.currentRoom.id}`, {
                method: 'POST',
                headers: { 'Authorization': `Bearer ${localStorage.getItem('access_token')}` }
            });
            
            const keepActiveBtn = document.getElementById('keepActive');
            if (keepActiveBtn) {
                keepActiveBtn.textContent = 'ƒê√£ gi·ªØ ho·∫°t ƒë·ªông';
                keepActiveBtn.disabled = true;
            }
        } catch (error) {
            console.error('Keep active error:', error);
        }
    }

    async reportUser() {
        if (!this.app.currentRoom) return;

        const reason = prompt('L√Ω do b√°o c√°o:');
        if (!reason) return;

        try {
            await fetch(`/chat/report/${this.app.currentRoom.id}`, {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json',
                    'Authorization': `Bearer ${localStorage.getItem('access_token')}` 
                },
                body: JSON.stringify({ reason })
            });
            
            this.app.showSuccess('ƒê√£ b√°o c√°o ng∆∞·ªùi d√πng');
        } catch (error) {
            console.error('Report error:', error);
            this.app.showError('Kh√¥ng th·ªÉ b√°o c√°o');
        }
    }

    disconnectWebSocket() {
        if (this.websocket) {
            this.websocket.close();
            this.websocket = null;
        }
        if (this.chatWebSocket) {
            this.chatWebSocket.close();
            this.chatWebSocket = null;
        }
    }

    handleChatMessage(data) {
        console.log('Chat message received:', data);
    }

    debug() {
        console.log('üîç Chat - Debug info:');
        console.log('  - Current user:', this.app.currentUser);
        console.log('  - Current room:', this.app.currentRoom);
        console.log('  - Pending connection:', this.app.pendingChatConnection);
        console.log('  - Status WebSocket:', this.websocket?.readyState);
        console.log('  - Chat WebSocket:', this.chatWebSocket?.readyState);
        console.log('  - DOM elements:');
        console.log('    - Chat room:', document.getElementById('chatRoom')?.classList.contains('hidden'));
        console.log('    - Waiting room:', document.getElementById('waitingRoom')?.classList.contains('hidden'));
        console.log('    - Searching:', document.getElementById('searching')?.classList.contains('hidden'));
    }
    
    testRestore() {
        console.log('üîç Chat - Testing restore chat state...');
        this.debug();
        this.restoreChatState();
    }
}

// Make ChatModule globally accessible
window.ChatModule = ChatModule;

// Add debug methods to global scope for testing
window.debugChat = () => {
    if (window.mapmoApp && window.mapmoApp.chatModule) {
        window.mapmoApp.chatModule.debug();
    } else {
        console.log('üîç Chat - MapmoApp or ChatModule not available');
    }
};

window.testRestore = () => {
    if (window.mapmoApp && window.mapmoApp.chatModule) {
        window.mapmoApp.chatModule.testRestore();
    } else {
        console.log('üîç Chat - MapmoApp or ChatModule not available');
    }
};
